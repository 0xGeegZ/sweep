

Human: Your name is Sweep bot. You are an engineer assigned to the following Github ticket. You will be helpful and friendly, but informal and concise: get to the point. You will use Github-style markdown when needed to structure your responses.


<relevant_snippets_in_repo>
<snippet filepath="tests/test_diff.py" start="145" end="167">
if __name__ == "__main__":
    replaced_new_file_content = fuse_files(old_file_content, new_file_content)
    assert replaced_new_file_content == new_file_content + "\n"
    replaced_new_file_content = fuse_files(old_file_content_a, new_file_content_a)
    assert replaced_new_file_content == old_file_content_a
    replaced_new_file_content = fuse_files(old_file_content_b, new_file_content_b)
    assert replaced_new_file_content == old_file_content_b
    replaced_new_file_content = fuse_files(old_file_content_c, new_file_content_c)
    assert replaced_new_file_content == new_file_content_c
    replaced_new_file_content = fuse_files(old_file_content_d, new_file_content_d)
    assert replaced_new_file_content == old_file_content_d
    replaced_new_file_content = fuse_files(old_file_content_e, new_file_content_e)
    assert replaced_new_file_content == new_file_content_e
    replaced_new_file_content = fuse_files(old_file_content_f, new_file_content_f)
    assert replaced_new_file_content == result_f
    replaced_new_file_content = fuse_files(old_file_content_g, new_file_content_g)
    assert replaced_new_file_content == new_file_content_g
    replaced_new_file_content = fuse_files(old_file_content_h, new_file_content_h)
    assert replaced_new_file_content == new_file_content_h
    replaced_new_file_content = fuse_files(old_file_content_i, new_file_content_i)
    assert replaced_new_file_content == old_file_content_i
    replaced_new_file_content = fuse_files(old_file_content_j, new_file_content_j)
</snippet>
<snippet filepath="tests/test_diff.py" start="0" end="70">
from src.utils.diff import fuse_files

# Test real one line change
old_file_content = """print("Hello World")"""
new_file_content = """print("Hello Sweep")"""

# Test middle cutoff
old_file_content_a = """\
print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")
"""
new_file_content_a = """\
print("Hello World")
# Rest of code
print("Hello World")
"""

# Test end cutoff
old_file_content_b = """\
print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")
"""
new_file_content_b = """\
print("Hello World")
# Rest of code
"""

# Test a real difference
old_file_content_c = """\
print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")
"""
new_file_content_c = """\
print("Hello World")print("Hello Sweep")
print("Hello World")
"""

# Test beginning cutoff
old_file_content_d = """\
print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")
"""
new_file_content_d = """\
# Rest of code
print("Hello World")
"""

# Test two changes
old_file_content_e = """\
def match(line):
    lowercase = line.lower().strip()
    semantic_match = "rest" in lowercase or "remaining" in lowercase or "..." in lowercase
    is_comment = lowercase.startswith("#") or lowercase.startswith("//")
    return semantic_match and is_comment
"""
new_file_content_e = """\
def match(line):
    semantic_match = "rest" in lowercase or "remaining" in lowercase or "..." in lowercase
    return semantic_match and is_comment
"""

# Test two changes
</snippet>
<snippet filepath="tests/test_prompt_constructor.py" start="0" end="55">
from loguru import logger
import difflib
from src.utils.prompt_constructor import HumanMessagePrompt

expected_original_prompt = '''
Repo: sweepai/sweep-test: test_repo_description
Issue: test_issue
Username: test_user
Title: test_title
Description: test_summary

Relevant Directories:
<relevant_directories>
test_file_path_a
test_file_path_b
</relevant_directories>

Relevant Files:
<relevant_files>
```
test_file_path_a
"""
test_file_contents_a
"""
test_file_path_b
"""
test_file_contents_b
"""
```
</relevant_files>
'''

expected_deletion_prompt = '''
Repo: sweepai/sweep-test: test_repo_description
Issue: test_issue
Username: test_user
Title: test_title
Description: test_summary

Relevant Directories:
<relevant_directories>
test_file_path_b
</relevant_directories>

Relevant Files:
<relevant_files>
```
test_file_path_b
"""
test_file_contents_b
"""
```
</relevant_files>
'''

</snippet>
<snippet filepath="tests/test_chatgpt.py" start="108" end="112">
        logger.info("Test passed!")

if __name__ == "__main__":
    # run_tests_for_deletion()
</snippet>
<snippet filepath="tests/test_chatgpt.py" start="60" end="65">
    if bot.messages_dicts == []:
        logger.info("Test passed!")
    else:
        logger.info("Test failed!")
        logger.info(f"Constructed messages: {bot.messages_dicts}")
</snippet>
<snippet filepath="tests/test_chatgpt.py" start="24" end="60">
def run_tests_for_deletion():
    repo_name = "sweepai/sweep-test"
    issue_url = "test_issue"
    username = "test_user"
    repo_description = "test_repo_description"
    title = "test_title"
    summary = "test_summary"
    file_path_to_contents = {
        "test_file_path_a": "test_file_contents_a",
        "test_file_path_b": "test_file_contents_b"
    }
    human_message = HumanMessagePrompt(
    repo_name=repo_name,
    issue_url=issue_url,
    username=username,
    repo_description=repo_description,
    title=title,
    summary=summary,
    file_path_to_contents=file_path_to_contents,
    )
    bot = ChatGPT.from_system_message_content(human_message=human_message, model="gpt-4"
    )
    if bot.messages_dicts == expected_original_messages:
        logger.info("Test passed!")
    else:
        logger.info("Test failed!")
        logger.info(f"Constructed messages: {bot.messages_dicts}")
        logger.info(f"Expected messages: {expected_original_messages}")
    bot.delete_file_from_system_message("test_file_path_b")
    if bot.messages_dicts == expected_deletion_messages:
        logger.info("Test passed!")
    else:
        logger.info("Test failed!")
        logger.info(f"Constructed messages: {bot.messages_dicts}")
        logger.info(f"Expected messages: {expected_deletion_messages}")
    bot.delete_messages_from_chat(message_key="system")
</snippet>
<snippet filepath="src/core/sweep_bot.py" start="72" end="103">
        raise Exception("Could not generate PR text")


class GithubBot(BaseModel):
    class Config:
        arbitrary_types_allowed = True  # for repo: Repository

    repo: Repository

    def get_contents(self, path: str, branch: str = ""):
        if not branch:
            branch = self.repo.default_branch
        try:
            return self.repo.get_contents(path, ref=branch)
        except Exception as e:
            logger.error(path)
            raise e


    def get_file(self, file_path: str, branch: str = "") -> ContentFile:
        content = self.get_contents(file_path, branch)
        assert not isinstance(content, list)
        return content

    def check_path_exists(self, path: str, branch: str = ""):
        try:
            self.get_contents(path, branch)
            return True
        except Exception:
            return False

</snippet>
<snippet filepath="src/handlers/on_ticket.py" start="41" end="237">
def on_ticket(
    title: str,
    summary: str,
    issue_number: int,
    issue_url: str,
    username: str,
    repo_full_name: str,
    repo_description: str,
    installation_id: int,
    comment_id: int = None
):
    # Flow:
    # 1. Get relevant files
    # 2: Get human message
    # 3. Get files to change
    # 4. Get file changes
    # 5. Create PR

    organization, repo_name = repo_full_name.split("/")
    metadata = {
        "issue_url": issue_url,
        "issue_number": issue_number,
        "repo_full_name": repo_full_name,
        "organization": organization,
        "repo_name": repo_name,
        "repo_description": repo_description,
        "username": username,
        "installation_id": installation_id,
        "function": "on_ticket",
        "mode": PREFIX,
    }
    posthog.capture(username, "started", properties=metadata)

    g = get_github_client(installation_id)

    if comment_id:
        logger.info(f"Replying to comment {comment_id}...")
    logger.info(f"Getting repo {repo_full_name}")

    repo = g.get_repo(repo_full_name)
    current_issue = repo.get_issue(number=issue_number)
    item_to_react_to = current_issue.get_comment(comment_id) if comment_id else current_issue
    eyes_reaction = item_to_react_to.create_reaction("eyes")

    def comment_reply(message: str):
        current_issue.create_comment(message + "\n\n---\n" + bot_suffix)

    comments = current_issue.get_comments()
    replies_text = ""
    if comment_id:
        replies_text = "\nComments:\n" + "\n".join(
            [
                issue_comment_prompt.format(
                    username=comment.user.login,
                    reply=comment.body,
                ) for comment in comments
            ]
        )

    def fetch_file_contents_with_retry():
        retries = 3
        error = None
        for i in range(retries):
            try:
                logger.info(f"Fetching relevant files for the {i}th time...")
                return search_snippets(
                    repo,
                    f"{title}\n{summary}\n{replies_text}",
                    num_files=10,
                    installation_id=installation_id,
                )
            except Exception as e:
                error = e
                continue
        posthog.capture(
            username, "fetching_failed", properties={"error": error, **metadata}
        )
        raise error

    # update_index.call(
    #     repo_full_name,
    #     installation_id=installation_id,
    # )

    logger.info("Fetching relevant files...")
    try:
        snippets, tree = fetch_file_contents_with_retry()
        assert len(snippets) > 0
    except Exception as e:
        logger.error(e)
        try:
            posthog.capture(
                username,
                "updating_due_to_fetch_fail",
                properties={"error": str(e), **metadata},
            )
            update_index.call(
                repo_full_name,
                installation_id=installation_id,
            )
            snippets, tree = fetch_file_contents_with_retry()
        except Exception as e:
            posthog.capture(
                username,
                "failed",
                properties={
                    "error": str(e),
                    "reason": "Updating index as fetching is not working",
                    **metadata,
                },
            )
            current_issue.delete_reaction(eyes_reaction.id)
            comment_reply(
                "It looks like an issue has occured around fetching the files. Perhaps the repo has not been initialized: try removing this repo and adding it back. I'll try again in a minute. If this error persists contact team@sweep.dev."
            )
            raise e
    
    # reversing to put most relevant at the bottom
    snippets: list[Snippet] = snippets[::-1]

    num_full_files = 3
    num_extended_snippets = 5

    most_relevant_snippets = snippets[-num_full_files:]
    snippets = snippets[:-num_full_files]
    logger.info("Expanding snippets...")
    for snippet in most_relevant_snippets:
        current_snippet = snippet
        _chunks, metadatas, _ids = chunker.call(
            current_snippet.content, 
            current_snippet.file_path
        )
        segmented_snippets = [
            Snippet(
                content=current_snippet.content,
                start=metadata["start"],
                end=metadata["end"],
                file_path=metadata["file_path"],
            ) for metadata in metadatas
        ]
        index = 0
        while index < len(segmented_snippets) and segmented_snippets[index].start <= current_snippet.start:
            index += 1
        index -= 1
        for i in range(index + 1, min(index + num_extended_snippets + 1, len(segmented_snippets))):
            current_snippet += segmented_snippets[i]
        for i in range(index - 1, max(index - num_extended_snippets - 1, 0), -1):
            current_snippet = segmented_snippets[i] + current_snippet
        snippets.append(current_snippet)

    human_message = HumanMessagePrompt(
        repo_name=repo_name,
        issue_url=issue_url,
        username=username,
        repo_description=repo_description,
        title=title,
        summary=summary + replies_text,
        snippets=snippets,
        tree=tree,
    )
    sweep_bot = SweepBot.from_system_message_content(
        human_message=human_message, model="claude-v1.3-100k", repo=repo, is_reply=bool(comments)
    )

    try:
        logger.info("Fetching files to modify/create...")
        file_change_requests = sweep_bot.get_files_to_change()
        logger.info("Getting response from ChatGPT...")
        reply = sweep_bot.chat(reply_prompt, message_key="reply")
        sweep_bot.delete_messages_from_chat("reply")
        logger.info("Sending response...")
        new_line = '\n'
        comment_reply(
            reply
            + "\n\n"
            + collapsible_template.format(
                summary="Some code snippets I looked at (click to expand). If some file is missing from here, you can mention the path in the ticket description.",
                body="\n".join(
                    [
                        f"https://github.com/{organization}/{repo_name}/blob/{repo.get_commits()[0].sha}/{snippet.file_path}#L{max(snippet.start, 1)}-L{min(snippet.end, snippet.content.count(new_line))}\n"
                        for snippet in snippets[::-1]
                    ]
                ),
            )
        )

        logger.info("Generating PR...")
        pull_request = sweep_bot.generate_pull_request()

        logger.info("Making PR...")
        pull_request.branch_name = sweep_bot.create_branch(pull_request.branch_name)
        sweep_bot.change_files_in_github(file_change_requests, pull_request.branch_name)

        # Include issue number in PR description
        pr_description = f"{pull_request.content}\n\nFixes #{issue_number}."

</snippet>
<snippet filepath="src/utils/diff.py" start="0" end="47">
import difflib


def fuse_files(old_file_content: str, new_file_content: str):
    """
    Replaces the new code with the old code when "Rest of code..." shows up.
    """
    old_file_content = old_file_content.strip("\n")
    new_file_content = new_file_content.strip("\n")

    def match(line):
        lowercase = line.lower().strip()
        semantic_match = "rest" in lowercase or "remaining" in lowercase or "..." in lowercase
        is_comment = lowercase.startswith("#") or lowercase.startswith("//")
        return semantic_match and is_comment

    old_lines = old_file_content.splitlines()
    new_lines = new_file_content.splitlines()
    matcher = difflib.SequenceMatcher(None, old_lines, new_lines)
    result_lines = []
    inserts = []
    deleted_lines = []
    sequence_match_op_codes = matcher.get_opcodes() # These are tag, old_start_idx, old_end_idx, new_start_idx, new_end_idx
    sequence_match_op_codes.sort(key=lambda x: x[3]) # Sort it by the new_start_idx
    sequence_match_op_codes = [(tag, i1, i2, j1, j2, old_lines[i1:i2], new_lines[j1:j2]) for tag, i1, i2, j1, j2 in sequence_match_op_codes]
    for tag, _, _, _, j2, old_chunk, new_chunk in sequence_match_op_codes:
        if tag == 'equal':
            result_lines.append('\n'.join(old_chunk))
        elif tag == 'replace':
            for line in new_chunk:
                if match(line):
                    result_lines.append('\n'.join(old_chunk))
                else:
                    result_lines.append(line)
        elif tag == 'delete':
            deleted_lines.extend(old_chunk)  # Store deleted lines for later use
        elif tag == 'insert':
            for line in new_chunk:
                if match(line):
                    inserts.append((j2, deleted_lines))  # Store the insert operation and associated deleted lines for later
                else:
                    result_lines.append(line)

    # Process insert operations that were stored for later
    for j2, lines in inserts:
        result_lines.insert(j2, '\n'.join(lines))
    result_lines = [line.rstrip() for line in result_lines]
</snippet>
<snippet filepath="tests/test_prompt_constructor.py" start="55" end="103">
if __name__ == "__main__":
    repo_name = "sweepai/sweep-test"
    issue_url = "test_issue"
    username = "test_user"
    repo_description = "test_repo_description"
    title = "test_title"
    summary = "test_summary"
    file_path_to_contents = {
        "test_file_path_a": "test_file_contents_a",
        "test_file_path_b": "test_file_contents_b"
    }
    human_message = HumanMessagePrompt(
    repo_name=repo_name,
    issue_url=issue_url,
    username=username,
    repo_description=repo_description,
    title=title,
    summary=summary,
    file_path_to_contents=file_path_to_contents,
    )
    constructed_prompt = human_message.construct_prompt()
    expected_lines = expected_original_prompt.splitlines()
    constructed_lines = constructed_prompt.splitlines()

    # Generate the diff output
    if constructed_prompt == expected_original_prompt:
        logger.info("Test passed!")
    else:
        diff = difflib.unified_diff(expected_lines, constructed_lines)
        logger.info('\n'.join(diff))
        logger.info("Test failed!")
        logger.info(f"Constructed prompt: {constructed_prompt}")
        logger.info(f"Expected prompt: {expected_original_prompt}")


    # Test delete_file
    human_message.delete_file("test_file_path_a")
    constructed_prompt = human_message.construct_prompt()
    expected_deletion_lines = expected_deletion_prompt.splitlines()
    constructed_lines = constructed_prompt.splitlines()
    if constructed_prompt == expected_deletion_prompt:
        logger.info("Test passed!")
    else:
        diff = difflib.unified_diff(expected_deletion_lines, constructed_lines)
        logger.info('\n'.join(diff))
        logger.info("Test failed!")
        logger.info(f"Constructed prompt: {constructed_prompt}")
        logger.info(f"Expected prompt: {expected_deletion_prompt}")
</snippet>
</relevant_snippets_in_repo>

<relevant_paths_in_repo>
tests/test_diff.py
tests/test_prompt_constructor.py
tests/test_chatgpt.py
src/core/sweep_bot.py
src/handlers/on_ticket.py
src/utils/diff.py
</relevant_paths_in_repo>

<repo_tree>
|- .gitignore
|- .pre-commit-config.yaml
|- .vscode
| |- settings.json
|- Dockerfile
|- README.md
|- deploy.sh
|- pyproject.toml
|- src
| |- __init__.py
| |- api.py
| |- core
| | |- __init__.py
| | |- models.py
| | |- prompts.py
| | |- sweep_bot.py
| | |- vector_db.py
| |- events.py
| |- handlers
| | |- __init__.py
| | |- on_comment.py
| | |- on_ticket.py
| |- utils
| | |- __init__.py
| | |- config.py
| | |- constants.py
| | |- diff.py
| | |- event_logger.py
| | |- github_utils.py
| | |- huggingface.py
| | |- prompt_constructor.py
| | |- utils.py
|- tests
| |- chunking_experiments.ipynb
| |- create_sample_issue.py
| |- example_code
| | |- chroma_fastapi.py
| | |- chroma_fastapi.py.chunks.txt
| | |- factorial.rb
| | |- factorial.rb.chunks.txt
| | |- query_builder.tsx
| | |- query_builder.tsx.chunks.txt
| |- recursive_chunking_experiments.ipynb
| |- test_chatgpt.py
| |- test_chunking.py
| |- test_deeplake.py
| |- test_dfs.py
| |- test_diff.py
| |- test_models.py
| |- test_new_ticket.py
| |- test_prompt_constructor.py
| |- test_tiktoken.py
| |- test_vector_db.py

</repo_tree>

These are the file changes.
We have the file_path, the previous_file_content, the new_file_content, and the diffs.
The file_path is the name of the file.
The previous_file_content is the content of the file before the changes.
The new_file_content is the content of the file after the changes.
The diffs are the lines changed in the file. <added_lines> indicates those lines were added, <deleted_lines> indicates they were deleted.
Keep in mind that we may see a diff for a deletion and replacement, so don't point those out as issues.

<file_path>
.pre-commit-config.yaml
</file_path>

<previous_file_content>
repos:
-   repo: https://github.com/sweepai/bot-internal
    rev: v2.5.0
    hooks:
    -   id: update-from-main
        name: Update branch from main
        entry: git fetch origin main && git rebase origin/main
        language: system
        files: ''
</previous_file_content>

<new_file_content>

</new_file_content>

<file_diffs>
@@ -1,10 +0,0 @@
-repos:
--   repo: https://github.com/sweepai/bot-internal
-    rev: v2.5.0
-    hooks:
-    -   id: update-from-main
-        name: Update branch from main
-        entry: git fetch origin main && git rebase origin/main
-        language: system
-        files: ''
-
</file_diffs>



Assistant: